import { NextResponse, NextRequest  } from "next/server";
import { prisma } from "@/lib/prisma";
import { getUserIdFromToken } from "@/lib/authService";

// ‚úÖ GET: ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏£‡∏≤‡∏¢‡∏ß‡∏±‡∏ô
export async function GET(req: NextRequest, context: { params: { date?: string } }) {
  try {
    console.log("üì• Fetching meals for date:", context.params.date);

    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏î‡∏∂‡∏á `params`
    const date = await context.params?.date; // ‚úÖ ‡πÉ‡∏ä‡πâ await
    if (!date) {
      console.error("‚ùå Missing date parameter");
      return NextResponse.json({ error: "Missing date parameter." }, { status: 400 });
    }

    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö `userId`
    const userId = await getUserIdFromToken(req);
    if (!userId) {
      console.error("‚ùå Unauthorized request");
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // ‚úÖ ‡πÅ‡∏õ‡∏•‡∏á `date` ‡πÄ‡∏õ‡πá‡∏ô `Date Object`
    const mealDate = new Date(date);
    if (isNaN(mealDate.getTime())) {
      console.error("‚ùå Invalid date format:", date);
      return NextResponse.json({ error: "Invalid date format." }, { status: 400 });
    }

    // ‚úÖ ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏£‡∏≤‡∏¢‡∏ß‡∏±‡∏ô
    const meals = await prisma.meal_records.findMany({
      where: { user_id: userId, date: mealDate },
      include: {
        meal_items: true, // ‚úÖ ‡πÉ‡∏ä‡πâ `meal_items` ‡πÅ‡∏ó‡∏ô `meal_record`
      },
    });

    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if (!meals || meals.length === 0) {
      return NextResponse.json({ error: "No meals found for this date." }, { status: 404 });
    }

    console.log("‚úÖ Meals retrieved successfully");

    return NextResponse.json(meals, { status: 200 });
  } catch (error) {
    console.error("‚ùå API Error (GET):", error);
    return NextResponse.json({ error: "Internal Server Error" }, { status: 500 });
  }
}

// ‚úÖ POST: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡∏ô‡∏±‡πâ‡∏ô
export async function POST(req: Request, context: { params: { date?: string } }) {
  try {
    console.log("üì• Incoming request to add food to diary");

    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö `params.date`
    const date = context.params?.date;
    if (!date) {
      console.error("‚ùå Missing date parameter");
      return NextResponse.json({ error: "Missing date parameter." }, { status: 400 });
    }
    console.log("üìÜ Received date:", date);

    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö `userId`
    const userId = await getUserIdFromToken(req);
    if (!userId) {
      console.error("‚ùå Unauthorized request");
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // ‚úÖ ‡∏î‡∏∂‡∏á‡πÅ‡∏•‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö `req.json()`
    let requestBody;
    try {
      requestBody = await req.json();
      if (!requestBody || Object.keys(requestBody).length === 0) {
        throw new Error("Request body is empty");
      }
      console.log("‚úÖ Received request body:", requestBody);
    } catch (error) {
      console.error("‚ùå Invalid JSON format:", error);
      return NextResponse.json({ error: "Invalid JSON format." }, { status: 400 });
    }

    console.log("üì¶ Request Data:", requestBody);

    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
    const { meal_type, food_id, quantity, calories, protein, carbs, fat } = requestBody;

    if (!meal_type || !food_id || !quantity) {
      console.error("‚ùå Missing required fields");
      return NextResponse.json({ error: "Missing required fields." }, { status: 400 });
    }

    const mealDate = new Date(date);
    if (isNaN(mealDate.getTime())) {
      console.error("‚ùå Invalid date format:", date);
      return NextResponse.json({ error: "Invalid date format." }, { status: 400 });
    }

    // ‚úÖ ‡πÉ‡∏ä‡πâ `upsert` ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ß‡πà‡∏≤ `meal_records` ‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á
    const mealRecord = await prisma.meal_records.upsert({
      where: {
        user_id_date_meal_type: {
          user_id: userId,
          date: mealDate,
          meal_type,
        },
      },
      update: {},
      create: {
        user_id: userId,
        date: mealDate,
        meal_type,
        total_calories: 0,
        total_protein: 0,
        total_carbs: 0,
        total_fat: 0,
      },
    });

    console.log("‚úÖ meal_records ‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏û‡∏ö‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß:", mealRecord);

    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ `mealRecord.id` ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
    if (!mealRecord?.id) {
      console.error("‚ùå Meal record ID is missing!");
      return NextResponse.json({ error: "Meal record ID is missing" }, { status: 500 });
    }

    // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÉ‡∏ô `meal_record`
    await prisma.meal_items.create({
      data: {
        meal_record_id: mealRecord.id,
        food_id,
        quantity,
        calories: calories ?? 0,
        protein: protein ?? 0,
        carbs: carbs ?? 0,
        fat: fat ?? 0,
      },
    });

    // ‚úÖ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ñ‡πà‡∏≤‡∏£‡∏ß‡∏°‡∏Ç‡∏≠‡∏á macros ‡πÉ‡∏ô `meal_records`
    await prisma.meal_records.update({
      where: { id: mealRecord.id },
      data: {
        total_calories: { increment: calories ?? 0 },
        total_protein: { increment: protein ?? 0 },
        total_carbs: { increment: carbs ?? 0 },
        total_fat: { increment: fat ?? 0 },
      },
    });

    console.log("‚úÖ Food added successfully");
    return NextResponse.json({ message: "Food added successfully." }, { status: 200 });
  } catch (error) {
    console.error("‚ùå API Error (POST):", error);
    return NextResponse.json({ error: "Internal Server Error" }, { status: 500 });
  }
}

// ‚úÖ DELETE: ‡∏•‡∏ö‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÑ‡∏î‡∏≠‡∏≤‡∏£‡∏µ‡πà
export async function DELETE(req: NextRequest) {
  try {
    console.log("üì• Incoming request to delete food entry");

    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö `userId`
    const userId = await getUserIdFromToken(req);
    if (!userId) {
      console.error("‚ùå Unauthorized request");
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // ‚úÖ ‡∏î‡∏∂‡∏á‡πÅ‡∏•‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö `req.json()`
    let requestBody;
    try {
      requestBody = await req.json();
      if (!requestBody || !requestBody.meal_item_id) {
        throw new Error("Missing meal_item_id in request body");
      }
    } catch (error) {
      console.error("‚ùå Invalid JSON format:", error);
      return NextResponse.json({ error: "Invalid JSON format." }, { status: 400 });
    }

    const { meal_item_id } = requestBody;
    console.log("üóëÔ∏è Deleting meal item:", meal_item_id);

    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ `meal_item` ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á ‡πÅ‡∏•‡∏∞‡∏î‡∏∂‡∏á `meal_records` ‡∏°‡∏≤‡∏î‡πâ‡∏ß‡∏¢
    const mealItem = await prisma.meal_items.findFirst({
      where: { id: meal_item_id },
      include: { meal_records: true }, // ‚úÖ ‡πÉ‡∏ä‡πâ `meal_records` ‡πÅ‡∏ó‡∏ô `meal_record`
    });

    if (!mealItem || mealItem.meal_records?.user_id !== userId) {
      console.error("‚ùå Meal item not found or does not belong to the user");
      return NextResponse.json({ error: "Meal item not found or unauthorized" }, { status: 404 });
    }

    // ‚úÖ ‡∏•‡∏ö `meal_item`
    await prisma.meal_items.delete({ where: { id: meal_item_id } });

    // ‚úÖ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ñ‡πà‡∏≤‡∏£‡∏ß‡∏°‡πÉ‡∏ô `meal_records` (‡πÄ‡∏ä‡πá‡∏Ñ null safety)
    if (mealItem.meal_record_id) {
      await prisma.meal_records.update({
        where: { id: mealItem.meal_record_id },
        data: {
          total_calories: { decrement: mealItem.calories ?? 0 },
          total_protein: { decrement: mealItem.protein ?? 0 },
          total_carbs: { decrement: mealItem.carbs ?? 0 },
          total_fat: { decrement: mealItem.fat ?? 0 },
        },
      });
    }

    console.log("‚úÖ Deleted successfully");

    return NextResponse.json({ message: "Deleted successfully" }, { status: 200 });
  } catch (error) {
    console.error("‚ùå API Error (DELETE):", error);
    return NextResponse.json({ error: "Internal Server Error" }, { status: 500 });
  }
}